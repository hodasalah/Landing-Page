const name = "John Doe";
Array.from(name);
//["J", "o", "h", "n", " ", "D", "o", "e"]
Array.of(name)
//["John Doe"]
name.split(" ")
//["John", "Doe"]
Array.of(...name)
//["J", "o", "h", "n", " ", "D", "o", "e"]
{
	The lifecycle of an HTML page has three important events:

DOMContentLoaded==> – the browser fully loaded HTML, and the DOM tree is built, but external resources like pictures <img> and stylesheets may not yet have loaded.
load==> – not only HTML is loaded, but also all the external resources: images, styles etc.
beforeunload/unload – the user is leaving the page.
Each event may be useful:

[1]- DOMContentLoaded==> event – DOM is ready, so the handler can lookup DOM nodes, initialize the interface.
[2]- load event – external resources are loaded, so styles are applied, image sizes are known etc.
[3]- beforeunload==> event – the user is leaving: we can check if the user saved the changes and ask them whether they really want to leave.
[4]- unload==> – the user almost left, but we still can initiate some operations, such as sending out statistics.
}


/*
mainHeading.style.color = 'blue';
mainHeading.style.backgroundColor = 'orange';
mainHeading.style.fontSize = '3.5em';
3 in 1
mainHeading.style.cssText = 'color: blue; background-color: orange; font-size: 3.5em';
*/
================================================
DOM
===
characters--->tag --->token --->node---->dom
doc.getElementsByClassName()==>
doc.getElementsByTagName()===>
/// return HTML collection
doc.querySelectorAll==>
// return NodeList
Although NodeList is not an Array, it is possible to iterate over it with forEach(). It can also be converted to a real Array using Array.from().
e.classList===>
// return DOMTokenList 

1- DOMTokenList.item(index)
2- DOMTokenList.contains(token)
3- DOMTokenList.add(token1[, token2[, ...tokenN]])
4- DOMTokenList.remove(token1[, token2[, ...tokenN]])
5- DOMTokenList.replace(oldToken, newToken)
6- DOMTokenList.supports(token)
7- DOMTokenList.toggle(token [, force])
8- DOMTokenList.entries()
9- DOMTokenList.forEach(callback [, thisArg])
10- DOMTokenList.keys()
11- DOMTokenList.values()


document.forms===>
///return HTML collection

-----------------------------------------------------
how browser convert html to dom>
-------------------------------
difference between {Node and node}
Node ---> like a blueprint of a building have tinny objects
nodes --> objects in the  Node
---------------------------------
Node (properties and methods)
props===>
1- Node.baseURI
2- Node.baseURIObject
3- Node.childNodes
4- Node.firstChild
5- Node.isConnected
6- Node.lastChild
7- Node.nextSibling
8- Node.nodeName
9- Node.nodeType
10- Node.nodeValue
11- Node.parentNode
12- Node.parentElement
13- Node.previousSibling
14- Node.textContent
methods===>
1- Node.appendChild(childNode)
2- Node.cloneNode()
3- Node.compareDocumentPosition()
5- Node.contains()
6- Node.getRootNode()
7- Node.hasChildNodes()
8- Node.insertBefore()
9- Node.removeChild()
10- Node.replaceChild()
------------------------------------------
Element interface
===========>
props===>
1- Element.attributes 
2- Element.classList
3- Element.className
4- Element.clientHeight 
5- Element.clientLeft 
6- Element.clientTop 
7- Element.clientWidth 
8- Element.id
9- Element.innerHTML
10- Element.outerHTML
11- Element.scrollLeft
12- Element.scrollTop
methods===>
1- Element.getElementsByClassName()
2- Element.getElementsByTagName()
3- Element.hasAttribute()
4- Element.hasAttributes()
5- Element.insertAdjacentElement()
6- Element.insertAdjacentHTML()
7- Element.insertAdjacentText()
8- Element.querySelector()
9- Element.querySelectorAll()
10- ChildNode.remove()
11- Element.setAttribute()
12- Element.toggleAttribute()
-----------------------------------------------------------
Document interface
===============>
props===>
1- Document.body
2- Document.fonts
3- Document.forms
4- Document.head
5- Document.hidden
6- Document.images
7- Document.links
8- Document.dir
9- Document.title
10- Document.URL
methods===>
1- Document.createElement()
2- Document.getElementsByClassName()
3- Document.getElementsByTagName()
4- Document.querySelector()
5- Document.querySelectorAll()
6- Document.write()
---------------------------------------------
EventTarget Interface
--------------------
have_just_3_methods===>
------------
1- .addEventListener()
2- .removeEventListener()
3- .dispatchEvent()
-----------------------------------------------------------------------
	* textContent  === innerHTML === innerText ===>
	--------------------------------------------
	1- textContent
	---------------
	* set or get contnet text of element evevn it hidden or not in webpage
	* its a Node property

	2- innerHTML
	-------------
	* set or get html code  in an element like span under div
	* it render html code but text-content not it convert to  plain text
	* Element Property

	3- innerText
	--------------
	* sets or gets text in element but with its css style if element has display none it won't get text if elelment has text transform uppercase it will gets text with uppercase
	* Element Property
----------------------------------------------------------------------
Create apage with js
===============
//////// createElement() 
---------------------------
isn't Node iterface or Element interface it is Document interface
to create content====>
--------------------
const myPara = document.createElement('p');
const textOfParagraph = document.createTextNode('I am the text for the paragraph!');
myPara.appendChild(textOfParagraph);

document.body.appendChild(myPara);

oR===
const myPara = document.createElement('p');
myPara.textContent='I am the text for the paragraph!';
document.body.appendChild(myPara);
---------------------------------------------------------------------
const mainHeading = document.querySelector('#main-heading');
const otherHeading = document.querySelector('#other-heading');
const excitedText = document.createElement('span');

excitedText.textContent = '!!!';
mainHeading.appendChild(excitedText);
otherHeading.appendChild(excitedText);
--> only will effect im otherHeading
========================================================================
[[[[[[[[[[   Inserting HTML In Other Locations
	==================================
	.insertAdjacentHTML()
	=====================
	Enter the .insertAdjacentHTML() method! The .insertAdjacentHTML() method has to be called with two arguments:
	* --> the location of the HTML
	* --> the HTML text that is going to be inserted
===>
	The first argument to this method will let us insert the new HTML in one of four different locations
===>

1- beforebegin – inserts the HTML text as a previous sibling
2- afterbegin – inserts the HTML text as the first child
3- beforeend – inserts the HTML text as the last child
4- afterend – inserts the HTML text as a following sibling
======>
<!-- beforebegin -->
<p>
    <!-- afterbegin -->
    Existing text/HTML content
    <!-- beforeend -->
</p>
<!-- afterend -->
=======>
const mainHeading = document.querySelector('#main-heading');
const htmlTextToAdd = '<h2>Skydiving is fun!</h2>';

mainHeading.insertAdjacentHTML('afterend', htmlTextToAdd);
============================================================
.removeChild()
.remove()
==============
--->
const mainHeading = document.querySelector('h1');
mainHeading.parentElement.removeChild(mainHeading);
--->
const mainHeading = document.querySelector('h1');
mainHeading.remove();
--->
============================================================
.firstChild() ----->return node could be text or space
.firstElementChild()----->return tag 
.parentElement()---->return parentElement of current node
.nextSibling() || nextElementSibiling()----->returns the next sibling of element
.previousSibling() || previousElementSibling() ----->returns the previous sibling of element
===============
DOM style====>
---------
.style.<prop>
.cssText
.setAttribute()
.className
.classList
===========
const mainHeading = document.querySelector('h1');
mainHeading.style.color = 'red';
mainHeading.nextElementSibling.style.backgroundColor = 'red';
==>
mainHeading.style.color = 'blue';
mainHeading.style.backgroundColor = 'orange';
mainHeading.style.fontSize = '3.5em';
==>
cssText--->
==============
g.style.cssText = 'color: blue; background-color: orange; font-size: 3.5em';
className--->
================
<h1 id="main-heading" class="ank-student jpk-modal">Learn Web Development at Udacity</h1>
//store the list of classes in a variable
const listOfClasses = mainHeading.className;
// logs out the string "ank-student jpk-modal"
console.log(listOfClasses);
const arrayOfClasses = listOfClasses.split(' ');
===> Now that we have an array of classes, we can do any data-intensive calculations:

1- use a for loop to loop through the list of class names
2- use .push() to add an item to the list
3- use .pop() to remove an item from the list

---------------
.classList===> 
=======================
// store the list of classes in a variable
const listOfClasses = mainHeading.classList;
// logs out ["ank-student", "jpk-modal"]
console.log(listOfClasses);

====> 
	The .classList property has a number of properties of its own. Some of the most popularly used ones are:

1- .add() - to add a class to the list
2- .remove() - to remove a class from the list
3- .toggle() - to add the class if it doesn't exists or remove it from the list if it does already exist
4- .contains() - returns a boolean based on if the class exists in the list or not
==>
const mainHeading = document.querySelector('#main-heading');
mainHeading.classList.toggle('richard');
==>

var a = {
	myFunction: function quiz() { console.log('hi'); }
};
var b = {
	myFunction: function quiz() { console.log('hi'); }
};
===> a.myFunction !== b.myFunction


var a = {
	myFunction: quiz
};
var b = {
	myFunction: quiz
}

===> a.myFunction === b.myFunction


function myEventListeningFunction() {
	console.log('howdy');
}

// adds a listener for clicks, to run the `myEventListeningFunction` function
===> document.addEventListener('click', myEventListeningFunction);

// immediately removes the click listener that should run the `myEventListeningFunction` function
===> document.removeEventListener('click', myEventListeningFunction);
myEventListeningFunction=====> in addEventListener this function has adifferent address but myEventListeningFunction==> have another address
so we have to store afunction in avariable to easy remove its eventand doesn't get anew same function
---------------------------------------------------------------------
Event Phases
============
There are three different phases during the lifecycle of an event. They are:
---------------------------------
1- the capturing phase
2- the at target phase
3- and the bubbling phase
addEventListener(type , func , true)
true----> mean use capturing phase
default is false  ---> use bubbling phase
==>const items = document.querySelectorAll('.quizzing-quizzes');
const el = items[1];

==>el.addEventListener('click', function () {
    console.log('You clicked on the 2nd quizzing-quizzes item!');
}, false);
//bubbling phase
======================================================================
here we will talk about performance 
==================================
if we want to create a div with 200 paragraph every p has evevnt listner with same func
like== this====>
--------------

const myCustomDiv = document.createElement('div');

for (let i = 1; i <= 200; i++) {
    const newElement = document.createElement('p');
    newElement.textContent = 'This is paragraph number ' + i;

    newElement.addEventListener('click', function respondToTheClick(evt) {
        console.log('A paragraph was clicked.');
    });

    myCustomDiv.appendChild(newElement);
}

document.body.appendChild(myCustomDiv);
here ===> we have 1 div 200 paragraph 200 eventlistner 200 func 
here web browser have to store 200 eventlistner 200 func 


how_can_we_reduce_them===>
--------------------------
By make afuntion and pass arefrence to the event listner  baecause we know that  the first way we make afunc inside every event listener  every func has its memory location so it seems that its same func but not it us new func  but here we make afunc and pass its reference to event so it actually same func 



const myCustomDiv = document.createElement('div');

function respondToTheClick() {
    console.log('A paragraph was clicked.');
}

for (let i = 1; i <= 200; i++) {
    const newElement = document.createElement('p');
    newElement.textContent = 'This is paragraph number ' + i;

    newElement.addEventListener('click', respondToTheClick);

    myCustomDiv.appendChild(newElement);
}

document.body.appendChild(myCustomDiv);
here web browser will store 200p 200event Listener 1 func
that's greate but we want to reduce event listner how
let_us_see===>
------------
let us add the event to the parent div
const myCustomDiv = document.createElement('div');

function respondToTheClick() {
    console.log('A paragraph was clicked.');
}

for (let i = 1; i <= 200; i++) {
    const newElement = document.createElement('p');
    newElement.textContent = 'This is paragraph number ' + i;

    myCustomDiv.appendChild(newElement);
}

myCustomDiv.addEventListener('click', respondToTheClick);

document.body.appendChild(myCustomDiv);
--------------
will here we have 200p 1event 1func
Now the browser doesn't have to store in memory two hundred different event listeners and two hundred different listener functions. That's great for performance`!

However, if you test the code above, you'll notice that we've lost access to the individual paragraphs. There's no way for us to target a specific paragraph element. So how do we combine this efficient code with the access to the individual paragraph items that we did before?
---------------------------------------------------------------
event__delegation==>.
====================
const myCustomDiv = document.createElement('div');

function respondToTheClick(evt) {
		console.log('A paragraph was clicked: ' + evt.target.textContent);
		-------------------------------------------------------------------
}

for (let i = 1; i <= 200; i++) {
    const newElement = document.createElement('p');
    newElement.textContent = 'This is paragraph number ' + i;

    myCustomDiv.appendChild(newElement);
}

document.body.appendChild(myCustomDiv);

myCustomDiv.addEventListener('click', respondToTheClick);

-----------------------------------------------------------------
if you want your script file being in head section you need event handelar to display your js and html 
document.addEventListener('DOMContentLoaded', function () {
	console.log('the DOM is ready to be interacted with!');
});
On what event target should we listen for the DOMContentLoaded event?
// document`
=======================================================
.createDocumentFragment() ==>
--------------------------
to create element  which won't added to dom  just to wrap elements
const fragment = document.createDocumentFragment();
for (let i = 0; i < 200; i++) {
	const newElement = document.createElement('p');
	newElement.innerText = 'This is paragraph number ' + i;

	fragment.appendChild(newElement);
}

document.body.appendChild(fragment); // reflow and repaint here -- once!
Recap
